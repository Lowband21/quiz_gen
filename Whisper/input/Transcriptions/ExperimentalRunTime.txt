 In this segment, we're going to study how to experimentally measure the amount of time it takes for functions and methods to execute. Why do you think it's important to time how long it takes for a function or method to run? We use a variety of different data structures to store data, and you've learned about many of these, such as a Python list, an array, a singly-dubbly or circularly linked list, and there are other structures as well that you'll learn about later. As the number of elements n that we store in our data structure increases, of course the processes that we use to access or change the data might take longer. And at some point, the number of elements in the data structure might become too large for us to be able to tolerate the amount of time that it takes. By timing our function, we can get an indication of how much data our algorithms can reasonably handle, and it also gives us a hint about when we need to redesign our code. You might think that if we double the number of elements, that means that the amount of time that it takes to execute an algorithm will double as well. But this is not always true. In other words, the relationship between the size of the data structure and the time that an algorithm takes is not necessarily linear. As an example, let's say we have an algorithm that when n is 1000, it takes two seconds to run. You can't assume that if you multiply the number of elements by 10 that it will necessarily take 10 times as long or 20 seconds to run. In fact, it might take 200 seconds or 2000 seconds or worse. And in fact, sometimes it might not be much worse at all. Understanding the relationship between the number of data elements n in a data structure and the time that an algorithm takes to execute is extremely important, and you'll continue studying this idea throughout your computer science career. Let's review how to find the time that it takes to execute a function or a method in Python. The most simplistic approach is the following. We use the time function in the time module to find the system time and we store that in a variable. Then we execute the function or method. And in the program when we return from that call, we again find out the system time storing in a new variable. The elapsed time is just the stop time minus the start time, and it's given in seconds. And that's how long it took the function or method to execute. Now this simplistic approach doesn't always work. So after I do a demo of the method that you're seeing here, I'll come back to these slides and summarize what we learned in the demo. I'm now in VS Code. What I have so far is a method that I've written that creates a Python list with n elements, n being a parameter that's passed. And I create the list by inserting at the start of the list at index zero elements into the list. Now it doesn't really matter what elements I put into the list because the important thing that I care about right now is just measuring the speed. So I just put i, the index of the loop. And I'm not returning anything because what's in the list really doesn't matter for measuring the time. However, I am going to print the list. So I'm going to call this function, execute this function, let's say with 10 elements, just to make sure that I haven't made a mistake. So here's my list with the 10 elements that I've inserted one by one into the head of the list. And that seems to be working. Now the timing that I'm going to do is not going to be for 10 elements. I'm going to do it for 100,000 elements the first time. But I'm probably going to want to change it. So instead, I'm going to create a variable called list length, and I'm going to store 100,000 in it. And I'm going to use that variable as the parameter to call my insert function. My create list by inserting at the start function. So now I'm ready to start doing timing. So as the method goes, I start by storing the start time. I need to call the time function in the time package. I also then, after the call to the function, I'm going to store the stop time. To do this, I have to, from the time module, import the time function. Now I want you to understand a little bit about this time that's coming back. So before I do the full timing test, I'm just going to print the start time. And you can see that it's quite a large number. And the total amount of time elapsed is the stop time minus the start time, both of which are quite large numbers. So it doesn't really matter as long as the difference is accurate. And so you might wonder what that start time is. And it is the number of seconds elapsed since what's considered the dawn of time. It's called the epoch. And on most computer systems, it's set to be midnight on January 1st of 1970. So that's the actual number of start time. But when you subtract stop time from it, the number won't be large because the difference is just the elapsed time. There's a value in having the time be based on a strict starting point, which is that you always get an absolute value and it's always distinct. So if you run this test tomorrow, you will get different values for the start time and the stop time. Now, I've left accidentally this print statement in my function that I'm timing, and it's important that I not put that in there because I don't want my time to include the amount of time it takes to print the list to the terminal. I now can compute the elapsed time as the stop time minus the start time. And I now want to do a print of that, but I'm going to format it a little bit nicely. So I'm going to make an output that says N. This is going to be a little header. N is the number of elements in my list. I'll put a tab and then my next header will say time per call. And then I'll output the information, which is the list length. Put a tab to format it nicely, and then I'll put the elapsed time here. And let me run it and see what happens. There's my result. N is 100,000 and the time for one call to list insert start is 3.27 seconds. I'm taking out the print statement of the start time. I don't need to see that any longer. And also, I really don't need to see this many decimal places on my number. So in formatting an F string, Python allows me to format it by saying .4F. And this means four decimal places after the decimal point. So that gives me a little bit of a nicer output if I don't need to see any more. Now, this was a demo of the simplistic way of evaluating the time that it takes for a function to run. And sometimes it doesn't work well. So I'm going to do another method, which is to time a function that doesn't create the list by inserting at the start of the list, but it creates it by appending to the end. Let me paste that code. So here's the code that does something very similar, but instead of inserting at the beginning of the list, the value i is just appended to the end of the list. And that is quite a different time to run. So I'm going to change my code to call listAppend, which is going to create a list with 100,000 elements by appending each new element to the end of the list. When I run it, you can see that the time per call is just for 1000th of a second. But this is not an accurate value, because when the times are small, and by small I'll say less than what's perceivable on a human scale, and we'll put the limit at one second. When the times are less than about one second, the value that you get for these time is not accurate. It includes too much extra time for the startup of the program, and too much inaccuracy if your computer ends up pausing in the background to do something else for a moment. So we need a new strategy, and the new strategy that we're going to employ is to call this function many times, then divide by the number of times we called it to get an average amount of execution time. So to do that, we're going to create a loop, and the number of trials is the number of times we're going to call or execute this function. So let's set that up, and I don't really know exactly how big it should be, but using this 0.004 as an estimate, it looks to me like I need to call the function maybe 250 times to get my total elapsed time over one second. So now let me improve my output here by time per call. I also want to output the number of trials, and I also want to output the total elapsed time. So I'm not just outputting the list length, and now it's not just elapsed time, because of course the elapsed time, which is the time per call, has to be divided by the number of times that I executed the function. I'm also going to output numTrials, and I'm also going to output the total elapsed time itself, because I want to make sure that that is over about a second. So let me run this, and now I have a more accurate time estimate for the time per call. The number of trials is 250, and the total elapsed time is one second. This didn't line up that well. Maybe I'll put in an extra tab here so that you can see this a little more clearly. Let me run it again. That didn't work too well. I'm not sure why I didn't get an extra tab in there. Oh, because I forgot to put an extra tab after this. Let me run that again so we get a cleaner output, and you can see that when n is 100,000, the time per call is about four milliseconds. The number of trials is 250, and the total elapsed time, this is close enough to one second, so we can be sure that we're getting an accurate time. That's the time per call on average. To summarize what we've done here, the technique of the simplistic approach is inaccurate since the elapsed time is often too small. So the improvement is to find out the current time, the start time, then call the function not once, but a specific number of times, numTrials we'll call it. Then we find the current time again, and we find the elapsed time by subtracting, but this time the elapsed time is not the time that it takes to execute the function. I need to divide by the number of trials to get the time for a single function call. Now to choose numTrials, the number of times to repeat the function call, what you need to know is that generally the larger numTrials is, the more accurate the time measurement is, and the total elapsed time should be at least one second. You can experiment to choose the number of trials and just keep fiddling with it to make sure that the time that you have, the total elapsed time, is long enough. In this next slide I'm showing you an example. This is the example that we just did, and I'm just putting it here so that you can pause and have a good look at it if you'd like. Here's the output roughly that we received from our experiment.