 The next data structure we'll study is doubly linked lists. Let me start with a review of singly linked lists and the way that we draw memory diagrams to represent them. You've already seen and implemented a singly linked list class. And here's an example of a memory diagram of a singly linked list with three entries. The head of a singly linked list is a reference to the first node in the list. Each node has a value and also a reference to the next node in the list. A None pointer in the next field indicates that we've reached the end of the list. Now by convention, the value stored in each of our nodes within a list must be of a consistent type. The value itself, though, is really just a reference which directs us to the data. The data itself could be ints, floats, or objects of a class. So a more accurate memory diagram actually looks like this. In the value field, we just have a reference that points us to the memory location where the value is stored. This makes for a pretty cluttered diagram. And also it takes away from the phenomenon that we're really trying to study right now, which is the linking structure of these lists. So we're going to stick with this first type of drawing, both for doubly linked lists and for singly linked lists. Singly linked lists can only be traversed in one direction. The structure of the pointers has each node pointing to the next node, and that allows us to traverse through the list, but only in the forward direction. And this can be really inefficient when we want to access an element at the end of the list or add an element to the end of the list or remove the last element. In order to do that, we have to traverse through the entire singly linked list. Singly linked lists offer the improvement of allowing traversal of the list in either direction, both forward and in the reverse direction. Here's the difference between the two types of lists. In a singly linked list, each node has a reference to the next node. But nodes in a doubly linked list have references pointing both to the next node and to the previous node. The addition of a reference that points to the previous node allows us to now traverse the list in the reverse direction as well as the forward direction. In a singly linked list, a reference to head points to the first node of the list. But since we want to traverse the list backwards, we now also maintain a reference called tail, which points to the last node in the list. Don't be fooled by these arrows that point backwards to an object. Because of the way that we draw the arrows, you might be thinking that somehow that arrow is pointing to the right hand side of the object. Actually any reference is pointing to the memory location where the beginning of that object is stored. Graphically, we could represent that as the upper left hand corner of these objects. If we drew the memory diagram this way, we'd see that head points to the beginning of object and prev points to the beginning of this object. This is a more accurate way of looking at a memory diagram. However, it makes the arrows cross each other, and so it's awkward to look at. We're going to stick with this drawing. Now another thing that I want you to notice is that for most nodes, the prev pointer points to a node. And if you look at the node it's pointing to, that next pointer must point back to the node that we started at. However, for the very first node, head points to the first node. But the prev pointer does not point back to head because head is just a reference, not an actual node. And the prev pointer in every node has to point to a node. It can't point to a reference. And for that reason, we're going to create the idea of a sentinel node, which will make implementation a little bit more consistent and simpler. What is a sentinel node? What we're going to do is make the references to the first and last item in the list the actual node objects, not just references to nodes. These are called sentinel nodes or dummy nodes. To remind ourselves that we are using full node objects and not just references, we're going to name the beginning of the list and the end of the list header and trailer. So here's our original diagram where we have head that's a reference pointing to the first node and a none as the prev pointer in that first node. Watch the change. We're creating header, which is a full node. Its next pointer points to the first true node and the prev pointer of the first true node now points backwards to the header. The header, because it's a dummy node, has nothing in its value and also none as its prev pointer. Look now at the trailer. The trailer has a similar phenomenon happening. Nothing as the value and nothing as its next pointer because it's a dummy node. However, its prev pointer points to the last true node in the doubly linked list, while the next pointer in that last true node points to trailer. Now sentinel nodes are technically node objects, but they don't contain any actual data and they are not themselves elements of the list. So the only valid contents of header is its next reference and the only valid contents of trailer are its prev reference. Notice that now all true elements of the list are internal nodes and this is what makes implementation of the doubly linked list class much easier because we don't have the need for special cases. Let's look at the extreme case of an empty list. Here's a diagram of an empty doubly linked list that uses sentinel nodes. Notice that there are two nodes, but both of them are dummy nodes. So there's no true elements in this list. However, the header, its next pointer will point to the trailer, while the trailer's prev pointer will point to the header. In this extreme case, when using sentinel nodes, new nodes are always inserted between existing nodes. The header and the trailer in the empty list being the existing nodes. And the reason that we do this is because it simplifies the special cases that would otherwise happen when we're either adding nodes to an empty list, adding or removing nodes at the beginning of the end or the end of the list, or deleting the last remaining node in a list. And you'll see how cleanly we can do this when we implement it.