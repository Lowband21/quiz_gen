 In this video, I'm going to tell you about the set abstract data type and show you a demo of how we might use it. What is that set abstract data type and what's it for? Remember first though that set is an abstract data type, and that means that really it's just an interface or a list of methods for interacting with the data. And as you've seen before with ADTs, the data itself is going to be stored in a data structure, maybe an array or a linked list, but which data structure we use and how it's used is part of the implementation, not part of the ADT. What this means is that actually we can implement the set ADT a couple of different ways using different underlying data structures, and we will do that this quarter. Now what a set is, is a collection of objects. In a set, the order of the elements doesn't matter, and there are no duplicate elements. So you're probably familiar with this idea from math, and the set idea from mathematics is an accurate model for what we mean by the set ADT. This is what the set interface should allow client code to do. First we should be able to find out how many elements are in the set. We should be able to add an element to a set or take one away from a set. We should be able to determine if the set contains a specific element. We should be able to get an iterator from the set interface that allows us to traverse the set. And finally we should be able to compute basic set operations, and those include union, intersection, and set difference. Let me describe in detail those three operations. The first one is union. You've seen this before as a Venn diagram. If I have two sets, S and T, the union is the set made by putting in all the elements from S and T together into one new set. Here's the definition in what we call set builder notation. S union T is all the elements S such that S is either an element in the original set S or it's an element in the original set T. This or sometimes confuses people because they think it should be an and. But actually it's correct for it to be an or because for each element in the union, we determine if it's in S union T by saying either it comes from S or it comes from T. By the way, it could also be an element of both. So this or in the mathematical context means one or the other or both. Intersection follows the Venn diagram you're used to. The intersection of S and T is the set of all elements that are in both S and in T. So the way we describe that in set builder notation is that S intersect T is all the elements S that have the property that S is in the original set S and that S is also in the original set T. And finally we have set difference. Here's the Venn diagram for that. This one you might be less familiar with. The idea of set difference is you take the set S and you throw away from it everything that is in the set T. So we can write this as S minus T, but I'll often call it S throw away T. I kind of think of it as you take S and then T takes a byte out of S by removing from S all of its elements. In set builder notation, this is written as S set minus T or S set difference T. And it's made of all the elements S such that S is in the original set S and it's also not in the original set T. By the way, some people write this not as a slash, but as a regular minus sign and that's fine too. So you can call this set difference or set minus. Here's the interface for the set ADT that incorporates the set properties, excuse me, the set operations and the other capabilities that I listed before. The first method is get size, which just returns the number of elements in the set. I have add an element E and that just puts the element E into the set S if it's not already there. Remember there's no duplicates, so we only add it if it's not there yet. Discard means remove the element E from S if it's there. It has no effect if the element E is not in the set S to begin with. Contains E returns a Boolean that tells us whether or not E is currently an element of that set S. Iter returns an iterator. We've learned about this recently and this iterator, the return of this iterator is what makes set an iterable interface. What it means is that you can use a content-based for loop to traverse a set. Union T, so when I call this method I have a set S and I would call S dot union T. That produces and returns a new set that's the union of S and T. Similarly, intersection with a set T returns a new set that's the intersection of S and T and difference T returns a new set which is the difference of S and the set T.