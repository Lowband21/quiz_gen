 We're continuing our experimental study of measuring the runtime of functions and methods. This time our focus will be a little different. We're asking the question now of how does the time grow and change as we increase the size of the list. We're going to do an experiment where we time how long it takes to build a Python list of 1000 elements, then 2000 elements, and so on up to 10,000 elements, by appending the elements one by one to the end of the list. So the list append function that we used in the previous video is the same, but we're going to be repeating the process for a range of values of the list size. The timing procedure that we'll use is the same as before, but we will be putting it inside of a loop that changes the value of n, the list length, meaning the final size of the Python list that we're building. We're interested in seeing how the time grows as the size of the list grows. I'm going to switch to VS Code and we'll do the experiment. I'm in VS Code now and I'm showing you the same code that we had in the previous video. I've got a function called list insert at the start, creating a list of size n, another function called list append that creates a list of size n by appending the elements to the end of the list, and then I have code here that's timing the length of time it takes to build that. So here I'm doing list append, and if I run this same as we had before, it takes about three one thousandth of a second when the list is 10,000, 100,000 elements long. But I said this time that I want a time starting at a list length of a thousand. If I run this code, you'll see that the total elapsed time is only seven or eight one thousandth of a second, which is too long to get an accurate reading. So we need to increase the number of trials. I'm going to try increasing it by a factor of 100. When I run it, still my elapsed time is a little too short to get an accurate time. So I'll just increase this a little bit more until I get an elapsed time that's over one second and the numTrials I've just determined by trial and error to get the total elapsed time correct. Notice that when I change numTrials, it doesn't change very much the average time per call because I'm running the function that many times and then dividing. So now I want to do something very similar, but instead of 1000, I want to have 1000, and do it again with 2000, 3000, and so on up to 10,000. So I'm going to change this code around a little bit. The first thing I'm going to do is move the printing of this header to the beginning, and I don't really need to see the number of trials any longer. So I'll delete that from my output. The next thing that I want to do instead of making the list length 1000, I want to be changing that. So I'm going to delete this initialization, and I'm going to put the entire computation, which is calculate the start time, run the trial, stop time, elapsed time, and output. And I'm going to indent that, and I'm going to repeat that process in the middle of a for loop. So list length is now going to vary its values starting at 1000, and it's going to go up to 10,000, but I'm going to say 11,000 here because I want to go just a bit past 10,000, and I'm increasing this list size, the list length, with a step size of 1000. So now basically I'm repeating the experiment, and you can see it running here. I've got an average time of 0.000029 seconds when the list length is 1000, and you can see that as the size of the list grows, so does the time. Now notice here that even though I'm not done running here, I can start finding some interesting behavior. When I changed the list size from 1000 to 2000, the time went from 0.000029 to 0.000059, and that's roughly double the time. So when I doubled the size of the list, I doubled the time. That's typical behavior for a linear function. I can check for here when I triple the time, I go from 0.000029 to 0.000085, and that is roughly triple the time. So triple the size, triple the time. When I multiply the size from 1000 to 10,000, that's a factor of 10, I'm roughly multiplying the time also by a factor of 10. We can see a nice visual depiction of this if we copy this data and copy it into Excel, and we can make a graph that shows us the runtime as a function of the size of the list. So I'm going to switch now to Excel. I'm using the Excel spreadsheet, but you are not at all obligated to do so. Use any spreadsheet program that you like. I'm going to go here, you can see that I copied the output from VS Code. I'm now going to paste it with a Command-V on Mac, it's Control-V in Windows, and this pastes the data into the spreadsheet. Now you can see this data got pasted appropriately into the spreadsheet, but when you do this, you might find that all of your data gets put into the first column. If that happens to you, please select your first column of data and hit, it's under Data, yeah, Data Text to Columns, and it'll give you the option here, Delimited is what you want, and then pick Tab and Space and hit Finish, and it'll separate your data into three columns. I didn't have the need to do this, because when I did my paste, it put it into three separate columns for me. So notice the first column is N, the size of the list. The second column is the average time for each call. The third column is the total elapsed time, which we really didn't need, because it was depending on the number of trials. So I'm just going to select the first two columns, and I'm going to create a scatterplot. I do that with, in Excel, Insert, here's scatterplot, and I personally like my scatterplot to be connected by lines. I think it's easier to see the graph, and if you look here, this looks very linear. So that's our first experiment, and let's switch back to the slides and see a summary of what we discovered. So what have we seen from this experiment? Here's the code that we just ran that repeated the time with a varying value of the length of the list. The output shows the time as a function of the list length. This was the output of VS Code. And then we noticed that, as we expected, the time increased when the size of the list grew, but we're actually interested not just in the fact that it increased it, but the rate that it does its increasing. So how quickly does the runtime grow? Experimentally, we found a graph of the runtime as a function of the list size, and it looks linear. The numbers that you see here are not identical to what we saw when we ran it, because this is an experiment, and each time we run the code, we'll get a slightly different result. Notice that an important feature of linearly growing functions is that when we double the size of the input, the output, the time, roughly doubles, and that is a nature of linearity. Let's move on to the next experiment. The second experiment is to add this time not to the end of the list, but to the beginning of the list. So now we're asking the question of how long it takes to build a Python list of 1000, 2000, and so on, up to 10,000 elements, this time creating the list by inserting them one by one into the beginning of the list. Now I've switched to VS Code and do the second experiment. I'm back in VS Code, and now remember what I wanted to do. I wanted to time, instead of list append, I wanted to time the function that creates the list by inserting at the beginning. So this list insert start creates a list of the length that I'm passing as the parameter. And remember, I'm repeating that as fixed number of trials, and then I'm doing a loop so that I can measure for 1000 as my size of the list, 2000, and so on. So let me run this this time, and you'll notice that when I run this, I'm waiting a really long time. And the reason is this function, list insert start, runs much more slowly. And so what do I do? I don't want to wait this long. I don't need the total elapsed time to be anything like 11 seconds. One second was long enough. So pause the video if you like and figure out what we're going to do to fix this. And I'll tell you now that the number of trials is nowhere near what I needed. It's actually much too large. So what I'm going to do, I'll come down to this running and I'll hit Ctrl-C to stop it, because I want to try this again with a smaller number of trials. So I'm going to try reducing the number of trials. Maybe I don't know how long, but it took 11 seconds and I didn't need that long. So I'm going to try doing it with 3000 trials. And the total elapsed time, it's not quite a second, but that's close to long enough. Now, the first thing that you're going to notice about this is that the total amount of time that it takes to build a list with 1000 elements compared to creating those by appending at the end is much longer, the time's longer. It's about 10 times as long. The second thing that you're going to notice about this is the rate of growth. When I'm creating a list with 1000 elements, it takes about almost three milliseconds. And when I double the size of the list, I don't double the amount of time. I nearly quadruple it. So what that means is that we're not seeing linear behavior here. In fact, we're seeing quadratic behavior. And I'll show you that when we do the graph. But this process is going to take much too long. I'm not going to show it all to you. I just want to point out here that the time is now like 17 seconds for elapsed time. So as I'm getting to longer and longer list lengths, I don't need as many trials. But my code was simple. I said the number of trials is 3000, and I didn't have it change as I progressed through the loop. And I could have done that to shorten my runtime, and I didn't just to keep things simple. So now what I'm going to do is pause the recording and I'll start again when this program is done running. All right, well, that code took several minutes to finish, but it has completed running now. So I'm going to take this output, copy it, and I'm going to now paste it into Excel and see if I can get a graph that gives me a good qualitative image of how the time is increasing as the size increases. I'm taking the data that I just copied, pasting it into Excel. I am not interested in the elapsed time in my graph. That's just something I wanted to keep an eye on and make sure the total elapsed time was long enough to get an accurate reading. I'll select the data that I want to create a graph for. Data, oh, sorry, it's under insert, insert. Scatter plot. And there's my graph, and you can see from this graph, it's clearly not linear. It looks parabolic. It's got an upward curve. We don't know if it's exactly parabolic. Later, we'll talk about how to determine that. But it does have this property that as I double the size of the list, it appears that the time is quadrupling approximately. And so that's behavior that matches a quadratically growing function. Let's summarize what we saw. The code was essentially the same. All we did was change it so that we called a different function. And the results showed that inserting at the beginning of the list takes much longer than appending to the end of the list. We, in fact, had to change the number of trials to accommodate this. The results also showed us the length of time increases more quickly than it did when we appended elements to the end of the list. Here's a result of running the list-inserted-start function with a range of list sizes. And the question we're asking was how quickly does the runtime grow? This is the graph we got about how quickly the runtime grew. It is clearly not linear. When the size of the list doubles, the runtime roughly quadruples. And the appearance is quadratic, parabolic as a function. Later we'll discuss how we determine if it really is quadratic in a more theoretical way rather than experimental. You should be asking yourself why inserting at the beginning of a Python list is slower than appending to the end of the list. And we'll be studying that in detail later.