 I'm going to demonstrate for you now the ideas in the previous video. Here is a Python list of names, five names, and I've written an index-based loop that traverses through the list using every possible legitimate index, looking up the name that goes with that index, and I'm just outputting the elements if they start with a T. So here's the output of this program. Now, we also learned in the first quarter of programming, not just how to do an index-based loop, but how to do a content-based loop. So here I'm saying, let the variable name take all possible values in the names list. And I don't need to look it up now because name automatically is the value in the list, traversing or iterating over every possible value. So this loop is identical in its output. Now, today we learned for the first time what's going on behind the scenes with that content-based for loop. Actually, what's happening is that an iterator is getting created, like in this equivalent loop. This iter function automatically calls the double underscore iter method for Python lists, and I'm storing that iterator in a variable called IT. The loop here now repeatedly tries to get the next element through the iterator, and this line next of IT automatically calls the double underscore next method in the iterator. And I'm saving the value in name, and then I can just do whatever I'm going to do with that value. The only extra check is that I need to handle a stop iteration exception when it's raised, because that means that I've reached the end of the loop. So that's how things work naturally with Python lists. But what I now want to do is the identical process, but with a singly linked list. So now I've recreated my list, not as a Python list, but as a singly linked list with the same five names, and I've written an index-based loop that goes through every possible value i for index values in the singly linked list, 0, 1, 2, 3, 4. I call get so that I get the name with the corresponding element in the singly linked list. And if it's a T, I output it. So this code again has identical behavior as the previous one using Python list. However, what we saw in the video is that this algorithm is O of N squared, and that's foolish to use because for traversing a singly linked list, we should never have an algorithm that's higher than O of N. So I'm going to comment this out and show that we really what we really want is a content-based loop, just like we did with lists for name and names. If the name starts with T, print the name. And this would be an efficient way to traverse the list because it would be done with an iterator. However, when I run this code, it doesn't work and it doesn't work. Because singly linked list is not an iterable class. I haven't implemented singly linked list to make it iterable. The exact same error will happen if I try to do the code that uses an iterator explicitly, I see that my singly linked list is not an iterable class. So now we need to learn how to make a class iterable. And that's what I'll talk to you about next. Here are the instructions for how to make a class iterable. There's a few steps. The first is that you have to make a new class to represent iterator objects that will traverse through your data. In that new class, you must store the current location for an iterator for an iteration. You need to keep track of which element you're on. It's going to need a constructor, in other words, a double underscore init method, and that should set up the current location to be whatever the start of your data is. It's also going to need a next method, and that method should return the value of the next element, and then it should advance further in preparation for the next call to next. Another change that has to be made is that the class itself that implements the data structure needs a double underscore iter method. The job of that method is just to instantiate the iterator object. Let's talk about how to do the traversal. For example, let's say we want to make singly linked list iterable. In the same file where we have our singly linked list class, we're going to create a new class called SLL iterator. That SLL iterator has to maintain a reference, which I'm going to call current, and that's going to keep track of the current node. As implementers of this class, we can choose whether current should point to the node that we're going to return next, or whether it should point to the current node. That's going to keep track of the current node that we're going to return next, or it could also point to the node right before it. In our implementation today, we'll have that reference, that current reference, point to the next node that we will be returning. So here's a picture. When we start our iteration, current will point to the first element in the list, because that's the next value that we will be returning. Every time next is called, it returns the value stored at current, advancing current to the next node. Every time next is called, that advancing continues. But notice that at some point after next is called, the next value after that is none. So current will now store the value none. And when next is called again, while current is the none reference, that's when the stop iteration exception must be erased. So now let's go through and follow these instructions and make singly linked list an iterable class. Here I am back in VS code and I'm editing the singly linked list .py file. Here is the file where I've implemented the class singly linked list. And notice that I've got another class in here called node that's a utility class used by singly linked list. So now I'm going to create another utility class called SLI iterator. This is the class that's keeping track of where I am in my traversal or iteration through the singly linked list. The first thing that it needs is an init method. This constructor needs to set up the current value of where I'm at in the iteration, but it needs to set it up to be whatever the head is of the list. So what I'm going to need is for whoever calls this constructor to pass to me what the head of the list is. The next method that I need to implement is the double underscore next method. This method is supposed to return the next value and in the list and then advance the pointer or reference to the next element. So the heart of this is that self.current has to traverse to the next node. But before I do that, I better save the value. The value stored in self.current, because before I traverse to the next node, I need to save it so that I have it available to return. So this is basically the correct code for next. However, remember that we're only supposed to do this if there really is a next value in the list. What that means is that I've got to check that self.current isn't none, because remember that when self.current is none, that means that I'm at the end of the list. So in that case, I better raise a stop iteration, meaning I'm at the end of the list. So that's pretty much it for SLL iterator, but the next thing that I was supposed to do is in singly linked list, create a double underscore iter method. All this method has to do is create a new SLL iterator and return it. However, remember that SLL iterator, the constructor has to know what the start of the list is. So I'm going to pass it self.head. In this method, self is the singly linked list. Whereas in the code I wrote before, I was in the SLL iterator. So self means the SLL iterator in those previous methods. So I think this is it. Let me save it. Let me go back to the code where I wanted to use this content based list to traverse or iterate through singly linked list. Let's see if it works now. Yay. So now this content based list is automatically calling the iterator that we just created. Now, don't forget that we could do this directly. It's not very common to do so, but it's really valuable at this point to make sure that you understand that this content based for loop is actually creating an iterator and traversing it with this next method. This is the behind the scenes work. And so now this version works as well because we have made singly linked list iterable. I just need to show you one last requirement, which is the Python language as it was designed requires every iterator class to also be iterable. So we need to add one more method here, which is an iter method for the singly linked list itself. But since the singly linked list iterator itself, but since the iterator already has an iterator, I can simply return self here. And you have to put this in because it's required in the definition of Python, so you can't just skip it. So that's it for the implementation of making singly linked list iterable.