 There's one more abstract data type that I need to tell you about now, which is the MapADT. Remember what an ADT is? It is an interface which has a list of methods for interacting with data. The data itself is stored in a data structure, maybe an array or maybe a linked list, but which data structure we use and how it is used is just part of the implementation, not part of the ADT itself. So let's look at what the MapADT is and what its structure and purpose is. A map stores data in pairs, which is a key together with a value. The key is often called a search key, and it represents a unique identifier, and the value is the data that's associated with that key. The key-value pair are called items in the map. Here are some examples. The registrar at a university could use a map to store student transcripts. The student ID could be used as the key, and the transcript itself would be the value. The items then look like this. The student ID is the key, and the transcript that goes with it is the value. We look up the transcripts by using the student ID as the search key, and for this to work, of course, every student ID has to be unique. You might look at this and think the transcript isn't a value. It's a whole collection of information, and you'd be right. So in reality, the way that this pair would work is that we would have a transcript object holding all the information about the student's work at a university, and the information stored in the value would actually just be a reference to that object. As another example, an airline reservation system could use a map to store customer flight records. The confirmation code would be the key, and the value would be the full record having all the information about the flight, including the name of the customer, the flight number, the date, the payment information, and so on. When you call an airline to get a reservation, they usually give you a confirmation code, a sequence of letters and numbers, and that would be the key to look up in the map. So the items look like the confirmation code together with the reservation record. And again, these confirmation codes have to be a unique identifier, and that's what allows us to use a map. As a last example, we could use a map in the following application. We could use it to count occurrences of words in a file. So every word that appears in the file would be a key, and the value would be an integer that gives the number of times that word has appeared. The items look like the word together with the number of times the word appears. So as we're processing the file, we would look up in the map the word and see how many times that word has appeared so far, and then we would update its value, incrementing it each time that that word appears. Here's a model for map that many people find helpful. It's the file cabinet model. So we can model a map by using a file cabinet. The items in the map are file folders, and each one has a label, the key. Here's a blown up image of that. And then the contents of the file folder are the value. We enter items into the map by storing them into the file cabinet. Then we look for items in the file cabinet by searching for them and locating them by finding the matching key that's the label on the file folder. So this model can help you in understanding what a map is. Let's look at the interface now for a map. Here's a list of methods that can be called on a map. This is a very minimal list. Many implementations of the map have additional methods as well, but we would at least need a way of finding the size. So getSize returns the number of items in the map. get with a key k will look in the map and find the value that goes with the key that's passed. If no such item exists in the map, then we would return None. Put takes two parameters, a key and a value. If the map doesn't already have an item with the key passed, then we would create an item with that key and the associated value and return None. If however, there already is an item in the map with that key value k, then we would keep the item but replace the value associated with that key and we would return the old value that used to be stored with that key. The next method is remove. We pass a key and this simply removes from the map any item that has that key k, returning the associated value. And if no such item exists in the map, then we return None. We next have a method called keys and that returns an iterable that contains all keys stored in the map. This allows us to traverse the map if needed. values returns an iterable containing all values stored in the map. Now keys will return an iterable with all keys and they will be unique. There will not be any duplicates because duplicate keys are not allowed. However duplicate values are allowed, two different keys could have the same value. And so the values method that returns the iterable allowing you to traverse all values may have repetition if multiple keys are associated with the same value. And finally, we have a method called items and that returns an iterable with all key value items that are stored in the map. So this is the interface for map and next I'll do a demo showing an example of how you might use this. So I'm in VS Code now and I'm going to show you an example of using a map. I'll first import the map class that I've written and we'll be implementing it together. I have implemented it just so I can do this demo, but we'll implement it together in class. The next thing I'm going to do is instantiate one of these ArrayMap objects and I'm going to store some information in it. Now this implementation of map uses an array to store the information. That's not necessarily the most efficient. So know that we'll be implementing a couple versions of it. The first one is this ArrayMap. What I'm going to do now is add an element to the map and the way that I do that is by calling the put method. The put method accepts a key, which is for me a license plate, and then the value that goes with it is the owner. So I'm using this map to store license plates as the key and the owner is the value that's associated with it. I'll add a second license plate now into my map and this has a new license plate with a new owner. Major Boothroyd is Q from the James Bond movies. And so what I'm going to do next is transfer the ownership of that license plate to a new owner, which is James Bond. So that actually wasn't right. What I meant to do was make a new line of code that transfers that same license plate to James Bond. So I told you that keys had to be unique and you might look at this and say, wait a minute, there's two keys, the license plate, that have the same value. However, they still are unique because notice that put, if I call it with a key that already exists in the map, updates the value associated with that key. So this Major Boothroyd is the value associated with the key, with this license plate. That's no longer valid because I've replaced Major Boothroyd with James Bond. Now notice the next line that I'm going to be putting into this map. I'm calling put two more times and notice I have two more keys, but these license plates, James Bond has a rotating license plate. So this car actually has three different license plates and the value that goes with it is all the same person. And this is allowed. We can have multiple keys with the same value. It's multiple values going with the same key that's not allowed. Let's now look at a couple of the other methods that we could use. We can now get a license plate, sorry, a value or an owner associated with a particular license plate. So this is basically a lookup. This get is going to return a value, which is the value that's associated with that license plate. So if I put that inside of a print statement, I find out the owner that goes with that license plate. Let me just show you a couple of the methods that allow us to traverse through the map. Here I'm calling license plates dot keys and this actually returns to us an iterable of all the keys. And because this is array map, that iterable is actually a list. But I don't have to print it. I could do anything. So for example, for K in license plates dot key, I can just output it. Let's do K dot starts with B. So I'm now going to be just looking at all the possibilities where the license plate number starts with B. I can print that key. So the point here is that you see that I'm allowed to iterate over that list. Sorry, I'm not allowed to iterate over whatever this keys method returns. And I could do the same thing with values. This time I'm just iterating through all the possible values that are associated with keys. And I'm just outputting all the ones that start with B. So it looks like it outputted twice but this first output, Bruce Wayne, was this printing of the license plate using get. So that's just a demo of how you use a map and the implementation will come in class.