 Let's now talk about procedures for managing doubly linked lists. For example, how do we insert and delete nodes from a doubly linked list? Let's start with inserting. I'm showing you the memory diagram of a doubly linked list with sentinel nodes and three elements. We've already talked about how the references for the value of the header and the prev reference for the header, as well as the value for the trailer and the next reference for the trailer, will always be none. So I typically will just draw those by leaving those references blank. Another thing that I want you to be keeping in mind is the following that has to hold true for every single node in a doubly linked list. If I start at a particular node and look at its prev pointer, go to the node that that refers to, and then look at the next pointer for that node, it better take me back to the node that I started at. Similarly, if I look at the next pointer for a node and then look at the node that it refers to and look at the prev pointer for that node, then that better take me back to the node that I started. This has to be true for every true node in a doubly linked list, or there's an error in the contents of the memory. Let's now talk about how to insert a node at the marked position. The first thing I'm going to do is just stretch out my memory diagram to give myself some room. Of course, this doesn't change the contents of memory, just my picture of it I need a little space in. So the first step is to instantiate a new node with a new value. After I do this, I need to fix four arrows, four references. The first two are the references in the new node itself. The next pointer has to point to the node on the right that I'm inserting between, and the prev pointer has to point to the node on the left that I'm inserting between. Next I'll change the reference that's pointing from the node before to the node after. It should now point, the next pointer should point, to the new node. To do this, I just have the node before's next pointer point to the new object that I've created. Similarly, the arrow from the node after the node I'm inserting between, its prev pointer has to point to the new node. The great thing about sentinel nodes is that the process we just looked at will be the same regardless of if I'm inserting a new node at the very head of the list or at the end of the list, because every node is now an internal node. Now let's look at how to remove an element from a doubly linked list. Let's say I want to remove the node that's marked. The first thing that I'm going to do is change the arrow that's pointing from the node before the node to delete and make it point to the node after. The way that I do this is by looking at the next pointer of the node that I'm to delete and copy that into the next pointer for the node before the node I'm deleting. Similarly, the prev pointer for the node after the node I'm deleting has to now be the node that the node I'm deleting is referring to in its prev pointer. Finally, I've got to take the value that's stored in the node that I'm deleting and return that value to the caller. Every method that's going to be deleting nodes will typically return the value stored in the node that's getting deleted. Now finally, you might look at this picture and think I need to do something about these arrows in the node that I just deleted. However, we don't have to because there are no remaining references to the marked node. As an object that's now unused, it's eventually going to be released during an automated process called garbage collection. The great thing again about sentinel nodes is that the process that we just looked at will work regardless of whether the node to be deleted is at the beginning or the end of the list. The same procedure works.