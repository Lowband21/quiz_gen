 Today we'll start implementing binary trees. Remember that a binary tree is a tree with a branching factor of 2, so that means that each node has at most two children. Here's an example of a tree with seven nodes. Pat is the root node. It has two children, Chris and Sam. Chris also has a left and a right child, Jordan and Casey, while Sam has a right child, Charlie, and Charlie has just a left child, Drew. So far we've been viewing trees as just an abstract data type, and this means we are free to choose whatever data structure we want to use to implement it. And so let's start talking about that. The easiest way to implement a binary tree is to represent the nodes as objects that include links to a parent node and also downward to two child nodes. Since there are at most two, we can refer to them as the left child and right child. Notice that each edge represents links then in two directions, from the parent to the child and from the child to the parent. To store a binary tree as nodes that are linked by references to the parent and to the child or children, we define nodes with the following structure. In this image, we see that a tree node will have four instance variables, a link to a parent, which is also a tree node, a link to a left and a right child that are also tree nodes, and then a link to the value, which is the contents contained in that node of the tree. So this image is going to tell us how to define the tree node class. Our tree node class is going to be defined within the same file as the binary tree class, much as we have done with nodes that we've used to implement other data structures. Tree node is going to need these instance variables, self.parent, self.left child, self.right child, and self.value. The image below is going to show us how tree node objects are linked together to reflect the hierarchical structure of a tree. Here's an abstract image of the tree where Providence is the root node with two children, Chicago and Seattle. Chicago has two children, Baltimore and New York. Here's the details that show what the tree nodes that represent this tree looks like. I start with my root node, whose value is Providence. Because it's the root node, its parent reference is none. This root node is the only node in the tree that can have none for its parent reference. Providence has a left child, which is the tree node with contents or value Chicago. And that node Chicago has a link or a reference back to parent. And notice that these two arrows together from parent to child and from child back to parent represent this one edge connecting Providence to Chicago. The same thing happens if I look at the links that represent the edge connecting Chicago to Baltimore. I've got the parent Chicago. Its left child is the node containing Baltimore. And then that node's parent is Chicago. Baltimore has two references to none that are its children because it is an external or leaf node. Pause the video and look in more detail at this image to make sure you understand all the links in this diagram. Finally, on the left, we have the instance variables of the tree itself, namely a reference to the root, which takes us to the top of the tree, and size, which is storing the number of nodes in the tree. Let's talk about more details of the implementation. Here are the components. The first thing we need is a utility class called TreeNode, and that includes the following. A constructor that initializes the instance variables parent, left child, right child, and value. We'll have a setter for the value of the nodes, and we've seen in the past that that can be very useful. We'll have an isInternal and isExternal Boolean method to determine whether or not a node is a leaf node. We'll have methods for computing the depth and the height of each node. Now the binary tree class itself that is built of TreeNodes has a constructor, instance variables, one to refer to the root TreeNode, and a value to represent the number of nodes currently in the tree. We'll have a method for adding a root node. We'll have methods for adding left and right children to a particular node. We'll have some informational methods, like getSize to return the number of nodes, and isEmpty and a treeHeight method. And finally, we'll have methods to output the contents of the tree in various ways. In the next video, I'll show you an example that would demonstrate how to use these methods to create a tree, and then after that, there'll be another video showing you the details of the implementation of many of these methods.