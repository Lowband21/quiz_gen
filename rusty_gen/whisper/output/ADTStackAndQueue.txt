## Reformatted by GPT3.5-Turbo: (1406 Words)

In this segment, we're going to cover abstract data types, abbreviated ADT, and two specific examples, namely stacks and queues.

First, what is an ADT? An abstract data type is an interface that just gives a list of methods for how to interact with data. The data itself is going to be stored in a data structure such as an array or linked list, but which data structure is used and how it is used isn't part of the ADT. The ADT just gives a model for what the methods do to the data, but it does not specify how it is implemented. That means that whoever is implementing the ADT is doing the choosing about what type of data structures are used and how those data structures are used. And often there are multiple choices, some of which are better than the others. This separation of how to interact with an ADT and how the ADT works internally is a powerful concept in computer science.

And today we're going to study two abstract data types, stacks and queues. We're also going to examine a couple of choices for which underlying data structures to use in a specific case and how to use these data structures. And we'll do this with the implementation of stack.

Let's talk about what a stack is. It is a last in first out data structure. The first example is trays in a cafeteria. The last tray that you put onto the stack is the first one that gets taken off. You do not take trays off the bottom of the stack. Last in first out data structure is also a first in last out because notice this tray at the bottom will not get removed until all the trays on the top have been removed.

Here's another example, a PEZ dispenser. A PEZ dispenser is for holding candy, and when you load it, you put the candy into the top. And the last candy that you put in is the next one that's going to come out.

Let's look at the stack ADT. What is in the abstract data type? Remember that the interface is just a list of methods in the stack ADT, and here's what they typically are. By the way, commercial examples of a stack might have many more methods than this, so we're just going to be doing the minimal.

The first method that you absolutely have to have in a stack is push. Push is the name for a stack where you hand the stack an element e, and this method puts that element onto the top of the stack. And by top of the stack, I mean the last element that has been added.

Pop, on the other hand, removes and returns the value that's currently at the top of the stack. Top returns the value of the top element of the stack, but it doesn't remove it from the stack. And sometimes this is called peak, and I really like the name peak because it gets across the idea that you're just looking, but you're not changing the contents of the stack.

Size is a typical method that just tells you the number of elements currently in the stack, and isEmpty returns true if the stack is empty and false otherwise.

Let's now see an example of what it might look like to use these methods. Here's an example of some code that uses a stack. Let's trace through it.

This first line of code, myStack equals stack, just creates a new stack object, which is currently empty. If at this point you called the isEmpty method, it would return true, and if you called size, it would return false.

In the next line of code, I'm saying push the number 17 onto the stack. So the number 17 gets created as an element in the stack, and the stack now has one element.

Now I'm going to push the value 42 onto the top of the stack. There it is. Now notice that I happen to choose to draw my stack with the left end as the bottom of the stack and the right end at the top. That's just a drawing. It doesn't have any meaning. And there's nothing about the code or the tracing of it that tells you how this code was implemented. It's just a picture of what I've got stored in the stack.

So next I'll push 23 onto the top of the stack. The size is now 3.

The next line of code is calling the top method, which recall will just return the number at the top of the stack, which is 23. And that's now inside of a print command, so the number 23 is going to get output to the console. So I'll put the output right here.

Next line of code calls pop. So remember that pop is going to return and remove this element 23 from the top of the stack, which I'm drawing on the right. So that line pops it and returns it, and it was in a print statement, so it gets output to the console.

Now I'm going to push another value onto the top of the stack.

And finally, I'll pop two elements, and those values get removed from the stack and returned. And since it's in a print statement, they're also getting output. Again, we don't know about the implementation of the stack class. We're just looking at how it gets used.

Let's look at queues now. A queue is a first-in, first-out data structure. Here's a couple of examples. The first is a line at the post office. In a line or queue, the first person that came into the post office is the first person getting served. When a new person comes in, they go to the end of the line, and they will not get served until everyone in front of them has already been processed. Another example is an escalator. The first person coming off the escalator was the first person who got on it.

Let's look at the queue ADT. Here's the interface. Instead of push, I have the name of the method of enqueue. It means add the element that's passed as a parameter to the back or end of the queue. Dequeue means remove and return the first element, the current first element in the queue. First returns the value of the first element in the queue, but doesn't remove it. And then size and isEmpty do the typical things that we would expect.

Let's look at an example of using these methods. This first line of code creates a queue, which is empty. Next, I enqueue the number 17, which puts 17 into the queue. My picture looks the same as before. As I enqueue, I'm just adding those elements onto the queue. But be careful because we're going to interpret this picture differently. 17 was the first element added into the queue, so it's going to be the first one that's processed when we start dequeuing. I think of this picture that I'm drawing having the beginning right here as the front of the line and the end, the last element that was added, as the back of the line. Therefore, when I call myqueue.first, the contents of the first element of the list is returned, and since it's in a print statement, that value is going to get output.

Now I'm going to start dequeuing. When I dequeue, I dequeue from the beginning or front of the list, and it's in a print statement. So the 17 is going to get output, and that 17 is going to get removed from the queue.

I'm going to enqueue again now, and when I enqueue, notice where I'm putting it, at the back of the line.

I'm going to move on and dequeue a couple more things, and when I dequeue, notice that the 42 now is the front of the queue, so that will be the next thing dequeued.

And then finally, I dequeue one more, so this 23 is going to be the last thing that gets dequeued. What's left in the list, this 49, was the last element that was enqueued, and this is the opposite of how things work in a stack, where the first element entered will be the last element removed.

## Reformatted By GPT4: (1413 Words)

In this segment, we're going to cover abstract data types, abbreviated as ADT, and two specific examples, namely stacks and queues.

First, what is an ADT? An abstract data type is an interface that just gives a list of methods for how to interact with data. The data itself is going to be stored in a data structure such as an array or linked list, but which data structure is used and how it is used isn't part of the ADT. The ADT just gives a model for what the methods do to the data, but it does not specify how it is implemented. That means that whoever is implementing the ADT is doing the choosing about what type of data structures are used and how those data structures are used. And often there are multiple choices, some of which are better than the others.

This separation of how to interact with an ADT and how the ADT works internally is a powerful concept in computer science. Today we're going to study two abstract data types, stacks and queues. We're also going to examine a couple of choices for which underlying data structures to use in a specific case and how to use these data structures. And we'll do this with the implementation of a stack.

Let's talk about what a stack is. It is a "last in, first out" data structure. The first example is trays in a cafeteria. The last tray that you put onto the stack is the first one that gets taken off. You do not take trays off the bottom of the stack. A "last in, first out" data structure is also a "first in, last out" structure because notice this tray at the bottom will not get removed until all the trays on the top have been removed.

Here's another example, a PEZ dispenser. A PEZ dispenser is for holding candy, and when you load it, you put the candy into the top. And the last candy that you put in is the next one that's going to come out.

Let's look at the stack ADT. What is in the abstract data type? Remember that the interface is just a list of methods in the stack ADT, and here's what they typically are. By the way, commercial examples of a stack might have many more methods than this, so we're just going to be doing the minimal.

The first method that you absolutely have to have in a stack is push. "Push" is the name for a stack where you hand the stack an element 'e', and this method puts that element onto the top of the stack. And by "top of the stack", I mean the last element that has been added.

"Pop", on the other hand, removes and returns the value that's currently at the top of the stack. "Top" returns the value of the top element of the stack, but it doesn't remove it from the stack. And sometimes this is called "peak", and I really like the name "peak" because it gets across the idea that you're just looking, but you're not changing the contents of the stack.

"Size" is a typical method that just tells you the number of elements currently in the stack, and "isEmpty" returns true if the stack is empty and false otherwise.

Let's now see an example of what it might look like to use these methods. Here's an example of some code that uses a stack. Let's trace through it. This first line of code, "myStack = stack", just creates a new stack object, which is currently empty. If at this point you called the "isEmpty" method, it would return true, and if you called "size", it would return 0.

In the next line of code, I'm saying "push the number 17 onto the stack". So the number 17 gets created as an element in the stack, and the stack now has one element. Now I'm going to "push" the value 42 onto the top of the stack. There it is. Now notice that I happen to choose to draw my stack with the left end as the bottom of the stack and the right end at the top. That's just a drawing. It doesn't have any meaning. And there's nothing about the code or the tracing of it that tells you how this code was implemented. It's just a picture of what I've got stored in the stack.

So next I'll "push" 23 onto the top of the stack. The size is now 3. The next line of code is calling the "top" method, which recall will just return the number at the top of the stack, which is 23. And that's now inside of a print command, so the number 23 is going to get output to the console. So I'll put the output right here.

Next line of code calls "pop". So remember that "pop" is going to return and remove this element 23 from the top of the stack, which I'm drawing on the right. So that line "pops" it and returns it, and it was in a print statement, so it gets output to the console. Now I'm going to "push" another value onto the top of the stack. And finally, I'll "pop" two elements, and those values get removed from the stack and returned. And since it's in a print statement, they're also getting output.

Again, we don't know about the implementation of the stack class. We're just looking at how it gets used.

Let's look at queues now. A queue is a "first-in, first-out" data structure. Here's a couple of examples. The first is a line at the post office. In a line or queue, the first person that came into the post office is the first person getting served. When a new person comes in, they go to the end of the line, and they will not get served until everyone in front of them has already been processed.

Another example is an escalator. The first person coming off the escalator was the first person who got on it.

Let's look at the queue ADT. Here's the interface. Instead of "push", I have the name of the method of "enqueue". It means "add the element that's passed as a parameter to the back or end of the queue". "Dequeue" means "remove and return the first element, the current first element in the queue". "First" returns the value of the first element in the queue, but doesn't remove it. And then "size" and "isEmpty" do the typical things that we would expect.

Let's look at an example of using these methods. This first line of code creates a queue, which is empty. Next I "enqueue" the number 17, which puts 17 into the queue. My picture looks the same as before. As I "enqueue", I'm just adding those elements onto the queue. But be careful because we're going to interpret this picture differently. 17 was the first element added into the queue, so it's going to be the first one that's processed when we start dequeuing.

I think of this picture that I'm drawing having the beginning right here as the front of the line and the end, the last element that was added, as the back of the line. Therefore, when I call "myQueue.first", the contents of the first element of the list is returned, and since it's in a print statement, that value is going to get output.

Now I'm going to start dequeuing. When I dequeue, I dequeue from the beginning or front of the list, and it's in a print statement. So the 17 is going to get output, and that 17 is going to get removed from the queue. I'm going to "enqueue" again now, and when I "enqueue", notice where I'm putting it, at the back of the line.

I'm going to move on and "dequeue" a couple more things, and when I dequeue, notice that the 42 now is the front of the queue, so that will be the next thing dequeued. And then finally, I "dequeue" one more, so this 23 is going to be the last thing that gets dequeued.

What's left in the list, this 49, was the last element that was enqueued, and this is the opposite of how things work in a stack, where the first element entered will be the last element removed.

## Original (1406 Words)

In this segment, we're going to cover abstract data types, abbreviated ADT, and two specific examples, namely stacks and queues. First, what is an ADT? An abstract data type is an interface that just gives a list of methods for how to interact with data. The data itself is going to be stored in a data structure such as an array or linked list, but which data structure is used and how it is used isn't part of the ADT. The ADT just gives a model for what the methods do to the data, but it does not specify how it is implemented. That means that whoever is implementing the ADT is doing the choosing about what type of data structures are used and how those data structures are used. And often there are multiple choices, some of which are better than the others. This separation of how to interact with an ADT and how the ADT works internally is a powerful concept in computer science. And today we're going to study two abstract data types, stacks and queues. We're also going to examine a couple of choices for which underlying data structures to use in a specific case and how to use these data structures. And we'll do this with the implementation of stack. Let's talk about what a stack is. It is a last in first out data structure. The first example is trays in a cafeteria. The last tray that you put onto the stack is the first one that gets taken off. You do not take trays off the bottom of the stack. Last in first out data structure is also a first in last out, because notice this tray at the bottom will not get removed until all the trays on the top have been removed. Here's another example, a PEZ dispenser. A PEZ dispenser is for holding candy, and when you load it, you put the candy into the top. And the last candy that you put in is the next one that's going to come out. Let's look at the stack ADT. What is in the abstract data type? Remember that the interface is just a list of methods in the stack ADT, and here's what they typically are. By the way, commercial examples of a stack might have many more methods than this, so we're just going to be doing the minimal. The first method that you absolutely have to have in a stack is push. Push is the name for a stack where you hand the stack an element e, and this method puts that element onto the top of the stack. And by top of the stack, I mean the last element that has been added. Pop on the other hand removes and returns the value that's currently at the top of the stack. Top returns the value of the top element of the stack, but it doesn't remove it from the stack. And sometimes this is called peak, and I really like the name peak because it gets across the idea that you're just looking, but you're not changing the contents of the stack. Size is a typical method that just tells you the number of elements currently in the stack, and isEmpty returns true if the stack is empty and false otherwise. Let's now see an example of what it might look like to use these methods. Here's an example of some code that uses a stack. Let's trace through it. This first line of code, myStack equals stack, just creates a new stack object, which is currently empty. If at this point you called the isEmpty method, it would return true, and if you called size, it would return false. In the next line of code, I'm saying push the number 17 onto the stack. So the number 17 gets created as an element in the stack, and the stack now has one element. Now I'm going to push the value 42 onto the top of the stack. There it is. Now notice that I happen to choose to draw my stack with the left end as the bottom of the stack and the right end at the top. That's just a drawing. It doesn't have any meaning. And there's nothing about the code or the tracing of it that tells you how this code was implemented. It's just a picture of what I've got stored in the stack. So next I'll push 23 onto the top of the stack. The size is now 3. The next line of code is calling the top method, which recall will just return the number at the top of the stack, which is 23. And that's now inside of a print command, so the number 23 is going to get output to the console. So I'll put the output right here. Next line of code calls pop. So remember that pop is going to return and remove this element 23 from the top of the stack, which I'm drawing on the right. So that line pops it and returns it, and it was in a print statement, so it gets output to the console. Now I'm going to push another value onto the top of the stack. And finally, I'll pop two elements, and those values get removed from the stack and returned. And since it's in a print statement, they're also getting output. Again, we don't know about the implementation of the stack class. We're just looking at how it gets used. Let's look at queues now. A queue is a first-in, first-out data structure. Here's a couple of examples. The first is a line at the post office. In a line or queue, the first person that came into the post office is the first person getting served. When a new person comes in, they go to the end of the line, and they will not get served until everyone in front of them has already been processed. Another example is an escalator. The first person coming off the escalator was the first person who got on it. Let's look at the queue ADT. Here's the interface. Instead of push, I have the name of the method of enqueue. It means add the element that's passed as a parameter to the back or end of the queue. Dequeue means remove and return the first element, the current first element in the queue. First returns the value of the first element in the queue, but doesn't remove it. And then size and isEmpty do the typical things that we would expect. Let's look at an example of using these methods. This first line of code creates a queue, which is empty. Next I enqueue the number 17, which puts 17 into the queue. My picture looks the same as before. As I enqueue, I'm just adding those elements onto the queue. But be careful because we're going to interpret this picture differently. 17 was the first element added into the queue, so it's going to be the first one that's processed when we start dequeuing. I think of this picture that I'm drawing having the beginning right here as the front of the line and the end, the last element that was added, as the back of the line. Therefore, when I call myqueue.first, the contents of the first element of the list is returned, and since it's in a print statement, that value is going to get output. Now I'm going to start dequeuing. When I dequeue, I dequeue from the beginning or front of the list, and it's in a print statement. So the 17 is going to get output, and that 17 is going to get removed from the queue. I'm going to enqueue again now, and when I enqueue, notice where I'm putting it, at the back of the line. I'm going to move on and dequeue a couple more things, and when I dequeue, notice that the 42 now is the front of the queue, so that will be the next thing dequeued. And then finally, I dequeue one more, so this 23 is going to be the last thing that gets dequeued. What's left in the list, this 49, was the last element that was enqueued, and this is the opposite of how things work in a stack, where the first element entered will be the last element removed.