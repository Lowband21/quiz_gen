 In the previous video, I showed you a short test program of ArraySet that created a couple of sets and demonstrated the union, intersection, and set difference operations. In this video, I'm going to show you the implementation of ArraySet. Remember that ArraySet is implementing the set ADT, which has the interface that I've shown here. This is the list of methods in the set ADT. So, I would recommend to you that you pause this video and look closely at the details and make sure that each method has an interface that makes sense to you, meaning that all the parameters match what you think they should be. Also, ArraySet is just one implementation of the set ADT. We're going to be using an array to store the actual data that is in the set. And that, of course, has to be a dynamic array because the size of the array has to change. So, we could use ArrayList, which is the dynamic array that we implemented last week. But we're going to instead use PythonList because PythonList is itself a dynamic array and has all of the capabilities that we're going to need. And because we're using an already implemented dynamic array, which has many useful methods, you'll be surprised perhaps to see how simple the implementation of ArraySet is. This is not the best implementation of the set ADT because it's not particularly efficient. But it's a good start for us to get an idea about how the set ADT works. I'm going to start with the constructor. The constructor is going to store the contents of the set, the elements of the set in a dynamic array, namely a PythonList. So, we only need one instance variable, which is going to start as an empty list. To comment the idea that I just demonstrated, I'm just telling you I'll store the contents of the set in a PythonList. And that PythonList is itself a dynamic array. You might think that I should also store the size of the set. However, since I'm using a PythonList, PythonList itself is storing the size. So, I don't need to duplicate that information by storing it in this class. And having been reminded of that, I now know that I can simply ask what is the size of the set, the PythonList of the set, and I can return that because that is the size of the set. The next method that I'm going to implement is I'll do string next because it's really useful to be able to see the contents of the set. So, what I'm going to do is create a string, and I'll start it by just having an open curly brace. Now I need to append to that string a string version of every element of the set. So, I can do that by iterating through the list that's storing all the elements in the set. And notice here that this forX in self.theSet is a content-based loop, and thus it's calling the iterator for the PythonList. Every X that comes back can be converted to a string and then appended or concatenated onto the end of the string that I'm building. But notice that I also need a comma and a space after each element. When I'm done, I can take the result and add a concatenate onto the end of it, a closed curly brace. However, there's a problem with this. And pause the video and see if you can figure out what the bug is. So, the problem is that this last element in the set has a comma space after it. So, my string is going to have the very last element followed by a comma space, and I don't want that. So, I could rewrite this loop so that I only add the comma space if I'm not at the last element of the list. However, I'm going to do something a little sneaky here, which is to take the result at this point and strip the comma space off of the end of it. Then I'll add the curly brace here, and I can return that result. So, this is kind of a sneaky way to get around that last comma that I didn't want. So, at this point, I've only implemented a few methods. Let me do one more. I'll do add, and then I'll do a quick test. So, if you weren't thinking completely thoroughly, you might just say, if I want to add the element v to my set, I could just say self.theset, and it's a list, remember, so I'll append onto the end of it v. And this would be correct, but for one important quality of sets, which is they have no duplicates. So, what I need to do first is make sure that v is not already in the set. If it's not in the set, then I can add it by appending to the end of the list, but if it's already in the set, I need to do nothing. So, instead, what I'll do is move this line, indent it a little, and I'll add an if statement. So, now I need to see if v is or is not in the set. So, I'm going to say, if it's not the case that v is in self.theset, then I'll add it. So, this method is actually quite simple. The reason that it's simple is because I'm using Python lists, which already have quite a bit of capability, and it allows me to see if that list contains the set v, excuse me, the element v. This is a place where you might notice that we've got quite an inefficiency, because in order to look for v in the list, I actually am going to have to traverse the entire list, and that is not too efficient. So, later in the quarter, we'll see better ways for storing information, for example, in a set or other ADTs, and we'll be able to speed up methods such as this add method. I've written enough now that I think I'd like to do a simple test. So, I'm going to switch over to a test program. Oh, I better go back here and save this thing. So, let me save ArraySet, and I'm going to go do a simple test. So, from ArraySet, which I've just implemented, I'm going to import ArraySet. I'm going to create a set S by instantiating a new ArraySet object, and notice that this calls the constructor. Line 3 calls the constructor that we just wrote, the init function that we just wrote. Now, I'll add a few elements to the set, and notice that I'm repeating this hello twice, and that's my way of just quickly testing that that add method worked correctly. So, I'm going to print the size, which should be, I'll let you pause and figure out what it should be, and then I'll print the set. Here goes. Hey, that worked, so I don't have any errors in my implementation. Let me return now to ArraySet, and I'll continue implementing methods in this class. So, let me see what I'd like to do next. I think I'm going to do contains next. So, contains is just supposed to return a Boolean that says whether or not the element v is in the set, and this, if I were you, I would pause this video and write that line of code. I'm storing the set itself, the contents of the self, of the set in self.theSet, so all I need to do is check to see if v is in there. So, I can say v in self.theSet. This calls a method already in the Python itself that determines whether or not that element is in a list, and that returns a Boolean, so I can simply return it. So, that one was pretty straightforward. Let's see, I'll do discard next. That means take an element out of a set. Now, it turns out that this is also an easy function to implement, method to implement, because Python list already has a remove method, and that method is going to remove the first occurrence of v that it finds in the list. Now, you might think, but that's a problem because it only removes one. However, self.theSet cannot have any duplicates in it. Every time somebody has to add an element, we checked. So, that means that self.theSet has at most one occurrence of each element, and thus, if I call the Python list remove method, it will remove that element if it exists. Otherwise, it will do nothing. So, I just call self.theSet.remove, and that's it. Let me implement one more method before I do another test. Remember, we just learned iterators recently, so remember this iter is supposed to return an iterator to the set. Now, the examples that we did previously for implementation had us creating a new class. For example, for singly linked list, we made a class called SLL iterator, and for doubly linked list, DLL iterator, you made one for ArrayList iterator. But we don't have to do that this time. This iterator is so easy because the contents of the list itself are stored in a Python list, and a Python list is already iterable. So, all I need to do is create an iterator for self.theSet. That calls the iterator function for Python list, and I can just return that. So, that's the end of my iterator. I've implemented now several more functions, methods, so I'm going to test those. Let me make sure to save this, and then I'm going to jump back to my test program. And continue testing. So, let's test the methods that we just wrote. The first thing I'm going to test is S.contains. Let's see if this worked to check if OLA is in the set. So, I'm going to print the result of this, and if I have done things correctly, that's going to be a Boolean true. And let's see what happens. Great, that worked. Now, the next thing I'm going to test is discard. So, I'm going to call S.discard, and let me take hi out of the list and see if that works. And then I'll print the set to see if my new set now just has hello and OLA in it. Okay, so that worked. Actually, I was using the wrong version because it didn't work. And the reason it didn't, and many of you probably noticed this when I was coding array set. Let me go back there and see what happens if I look at self.vusset.remove. The error here says, whoops, list.remove is supposed to have an argument. So, if you look back, I have a bug right here, which is because I forgot to pass the value of the element that I'm trying to remove. So, let me save that and let me go back to this test. And now it does work. So, I was able to discard an element. Now, let's see what happens if I try to discard an element that doesn't exist. So, I'm going to try removing gdaymate from the list, and let's see what happens. So, what happened is this self.vusset.removeV failed because the remove method in the Python list will raise a value error if the element is not in the list. However, we don't want our discard method to do that. So, I need to add something to this, which is I'm going to put the remove in a try-accept block. The accept block doesn't need to do anything. So, I could say pass or I could say return. So, what this does is suppresses the raising of the exception because our interface doesn't require that. So, let me save array set, run this again, and now this discarding of gdaymate didn't have any effect on the set, but it did run. Let me show you by printing this. All right, so that worked. So, let me go back to array set and just double check. I think I've implemented everything except for the three set operations, and that is something that we will do together in class and in lab.