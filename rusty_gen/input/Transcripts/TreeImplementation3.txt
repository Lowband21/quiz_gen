 Now let's start implementing the BinaryTree class. The name of the class is BinaryTree, and we start with a constructor. The job of this constructor is to initialize the instance variables, and there are two of them. The tree root, which we'll initialize to be none because the tree is going to be getting empty. And the size is the number of nodes that have been added to the tree, and that begins at zero. I feel already that I need to implement TreeNode because I'm not going to be able to put anything into the tree until I know what a TreeNode is. So I'll start implementing that class. It has a constructor. And that constructor needs four pieces of information, the parent, the left child, the right child and the value. I'll use the value to set the value, the contents of the node, and then all the other instance variables get set in the natural way. So parent, left and right are set according to the parameters that are passed. Let's see, the next thing I'm going to do is write some fairly simple but useful methods. For example, let me write isExternal. That method returns a Boolean, and thinking about what an external or leaf node is, you can pause the video and think about this. And node is external if both of its children are none. So I'm going to compute self.leftChild is none and self.rightChild is none. And if both of those are true, that's what I want to return. isExternal, very similar. I could rewrite it, but I think what I'm going to just do is just return the negation of... Let's see, I meant to say internal here. An internal node is not a leaf node, so I could just compute it as either the left child or the right child is not none. But instead, what I'm going to do is just call self.external and return the negation of that. Another essential method in this class is the method that will return a string representation of the tree node. And this is straightforward. I'm just going to take the value and convert it to a string, and that's what I'll return. I'm also going to write repper, which just does the exact same thing as string, and it allows us in Python to output in case we ever store tree nodes in a list. Just want to do the same thing that I do in string. I think that's the only absolutely essential methods within the tree node class. So now I'm going to return back to binary tree. I can implement get size. That's pretty easy. It returns an int, and that's just the size, the number of nodes in the tree that's already been, the number of nodes that have already been added to the tree. And the next thing I'm going to do is add right. No, I better do add root first so that I can create the first element in the tree, the root node. Now, this method needs to be told what the value of that node will be. And I do need to worry about one thing, which is what if there already is a root? If self.root is not none, then that means that a root has already been added to the tree, and it's an error for the user of this code to add a root again. So what I'm going to do in that case is raise an exception. I'll use value error and my error message will be binary tree dot add root. Root already exists. Now that I know that there is no root node, I'm going to create one. And I do that by creating a tree node. And since this is the root, there's no parent and the node is new. So there's no left child or right child. And the value is just the value that's been passed to me. That calls the constructor for the tree node, and I now need to save that in self.root. Of course, I need to return the node that just got created. So I'll return self.root. And I've forgotten one thing. Pause the video to see if you can figure out what it is. I also need to increment the size of the tree. So this now should work. If I go back to the demo code that I have, none of this later part of the code will work. But I should be able to add a root to that tree. And I don't really know if this... Oh, I know what happened. I forgot to save this. Let me run this. And the code ran, but nothing got output. So maybe after this, I'll print the tree and see what happens. Oh, but I didn't implement the string method yet. So all that gets output is the default string, which just gives the memory location of that object. But maybe I can do a little testing. Let me print myTree.getSize and make sure at least that's working. OK, good. So I've added one node and so now the tree has one element. Let's see if I can add some children now to this tree. What I'm going to do is create the addRight method. And this time I need to know which parent node I'm adding a right child to. And I need to know the value. Now, it would be an error, just like when I added the root, if there already is a right child for that node. So if it's not the case that the parent node passed to me. It's right child. It's not none, then that's an error. So I'm going to raise an exception like I did before for add root. Right child already exists. OK, so now there's space to put the right child. So I'm going to create a new tree node with the parent node is parent, but I don't know the children. There are no children, so I'll call those none. And I'll save the value. Now, this node needs to be put somewhere, and where I'm going to put it is the right child of the parent node that they passed to me. I need to increment the size. And then I can return this new node that got created. So that looks like the addRight method. If I go back to my demo, I can't add left, but I can add right. Let's see what other nodes I can add right to. I'm just trimming this tree down, given what I've implemented so far. Yeah, it looks like I can do that much. Oops, I didn't do add left yet, so I can only do add right. So let me do this again. And I'll do the printing of the tree and the size of the tree after that creation. And what I see is that I've got three nodes, but I still haven't seen the output of the tree, because I haven't implemented that yet. So we have just implemented a few methods, and in class, we'll start implementing the rest of them, like addLeft, the string method, and the string method. AddLeft, the string method, and then we'll write the node height and depth methods to go into the TreeNode class.