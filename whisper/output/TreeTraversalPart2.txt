 So continuing here with the study of traversal of trees, we've already done the pre-order traversal, which says, process or visit the root node before then doing a pre-order traversal on each of the subtrees, and a post-order which says, visit all of the elements in all of the subtrees before processing or visiting the root node. So an in-order traversal is processing the root node in between the children, and so this is only specific to binary trees. Binary trees have a left child and a right child, so what it means is that in an in-order traversal, we visit the nodes by doing an in-order traversal on one of the child's subtrees. For us, we'll always start with the left child, then process the root node, and then do an in-order traversal on the other of the child's subtrees, which for us will always mean the right. Again, just like pre-order and post-order, this is recursive, and it means that the implementation will be recursive, and thus it uses a stack because recursive methods automatically use the call stack. So this is another depth-first search that uses a stack, and here's the algorithm. If p has a left child, then do an in-order traversal of the left child. Then visit the the root node for this subtree, and then if p has a right child, do the in-order traversal on that right child. Let's do an example. What order are the nodes visited in the above tree using an in-order traversal? I'm going to let you try this, so please pause the video and look at the video to see if you can figure out how this works. Okay, here's the solution. In the in-order traversal, I start by calling the the method for my root node, but before I process it, I need to handle the left child. So I drop down here to this child, and now I'm going to process this, but to process this child, this subtree, I need to first process the left child, and to do this one I need to first process the left child, and finally to do this I need to process the left child. So notice this is why we need a stack. We need to remember which nodes we're in the middle of processing, so that when we complete this, for example, this three, we go back up to the plus, which was its parent, and then since it's in order, we then do the right subtree, returning to the root node, then the right subtree of it, returning to the root node in that recursive call, and finally I need to do the right child of this node, the slash. To do this same in-order traversal, I go to the right child, but I can't process it until I do its left child, and I can't process it until I do its left child. So the nine is the next, then the minus five, back to the root plus, then the two, and now it's an in-order traversal, and I finished the left subtree for the main root node. So I process the root node, the actual root node of the entire tree, and then I process the right subtree of it. And same pattern, before I can do the plus, I have to do its left child, and before I can do it, I need to do its left subchild. So I process the three, then the times. I think you're getting the pattern here. So I do an in-order traversal on the right subtree of the times, so that's the seven minus four, back up to the plus, and then the six, and I'm done. Try another one. Here's a subtree, here's a tree. List the order that the nodes are visited in an in-order traversal. Pause the video and make sure that you have this, and then I'll show the solution. The nodes are visited in the order four, two, five, and in-order I do the one, and then seven, six, eight, three, and there's no right child of three, so I'm done. The last type of traversal we'll look at is a breadth-first traversal, and it says it's specific to binary tree. That's an error in my slides. Hold on a second. Okay, so in a breadth-first traversal, we visit all nodes at a specific depth before proceeding to nodes at the next deeper level. So what that looks like is first process the root node, then process all nodes at depth one, next all nodes at depth two, etc. until the maximum depth of the nodes is reached. Now you know this means that we're going to be using a queue. The description is iterative, and here's the algorithm for the breadth-first traversal. Initialize a queue to contain the root node, and then as long as the queue is not empty, dequeue the element and perform the visit action on that node that just disappeared. That got dequeued, and then for every child, enqueue that child. Here's an example. We process the root node one and then all the elements at root at depth one and then all the elements at depth two, and that's it for this tree. This golden goes up to depth two, and we're typically here going from left to right. Here's another example. Here's a tree. List the order that the nodes are visited in a breadth-first traversal, and when there's a choice, proceed left to right. Pause the video and write the answer down, and then you can check to see if you got it correct. I'll show the answer now. We process the nodes, first the root node and then all the depth one nodes, all the depth two nodes in order, and then all the depth three nodes in order, and that's it. You get a chance to practice this and a couple of questions. In class, we'll do the implementation and talk about what the applications are for each of these methods. Thank you.