 Let's look at how to traverse all elements in a tree. It's different than traversing elements in a linear data structure. So remember that ordered lists have a linear structure. One element follows the other follows the other. So traversing a list, meaning visiting every element in a list, is very straightforward. For a singly linked list, we just start at the head and we iterate through the list by just repeatedly visiting each next note. Doubly linked lists have a next and a prev pointer, so we can just traverse the structure going both backwards or forwards. And for an array, we traverse by incrementing the index. And in an array, we can traverse backwards by starting at the last index and decrementing the index. However, a tree has a completely different structure. It's hierarchical. So visiting each note in the tree requires us to have a systematic process. And there are several ways to do this, each of which has its advantages. The first way is called pre-order traversal, and it's a type of depth first search. Post-order traversal is another type of depth first search. In-order traversal is a third type of depth first search that only works for binary trees. And finally, we have a breadth first traversal. And I'll go through each of these ways of traversing every element of the tree one by one. Let's start with pre-order. In a pre-order traversal, we visit the nodes in this order. We first process the root node. By process, I mean do whatever action it is that we're trying to do in the traversal of this tree. And in the beginning, the first technique that we'll use is just simply to print the contents of every node. So here, I would mean first print the contents of the root node. Then do a pre-order traversal on each child sub-tree. So I'm defining recursively what I mean by a pre-order traversal, and our implementation will also be recursive. So this might not be clear right away the first time you see this. Let me give you the algorithm for a pre-order traversal. So the algorithm works like this. First perform the visit action, meaning in our simplest example, just print the contents. But it may be something else. It may be like modifying the contents in some way or searching for a particular element. So we perform that visit action for position P, which will, in the beginning, start with the root node for. And then for every child, we call pre-order, meaning this same algorithm, and we call that on the child node. Now the order that we do is not specified in this algorithm. But for us, we'll typically be going left to right. Okay, let's do an example of this. I have a tree here, and I want to traverse it in with a pre-order traversal. So the algorithm says to begin at the root node. So I'll process this root node. Then the next thing I'm supposed to do is one by one go through the children, which here I have title as the child, and do a pre-order traversal on that child. So the pre-order traversal says process the root node. And I'm done here because this node has no children. Then I go to the next child of the root node, and I process it, and then all its children, but it has no children. So then in my for loop, I go to the next child. And now I do a pre-order traversal on each of its children. So I visit this section 1.1, and that's a leaf node. So I'm done, section 1.2, and so on. Please pause the video and complete for yourself this pre-order traversal. And I'll show you the final solution. Okay, hopefully you've had a chance to try this for yourself. And here's the final solution of the order that those nodes get visited in a pre-order traversal. Now let's go on to another example of this. Here's a tree. And what I want you to do is, again, pause the video and list the order that the nodes are visited in a pre-order traversal of the above tree. And when there's a choice, proceed left to right. So solve this now, and I'll give the answer. So I start at the root node, process the whole subtree hanging off to the left. And in a pre-order, that means process the root node and then the children. When I finish the subtree to the left, I move to the subtree to the right, process the root node, and then one by one go through the children. And each one of those, I process the root node and then the children. So the order is 1, 2, 4, 5, 3, 6, 7, 8. Let's now look at post-order traversal. We're again going to be traversing, visiting each of the nodes in the tree, but this time it's going to be in a different order. This time, in a post-order traversal, we visit the nodes in this order. First do a post-order traversal on each child's subtree, then process the root node. Again, this description is recursive, and so our implementation will also be recursive. Notice when I say post-order rather than pre-order, what I'm talking about is the order in which I process the root node. In post-order traversal, I process the root node after I process the traversal on the child's subtrees, whereas in pre-order, I process or visit the root node first. Here's the algorithm for post-order. In the post-order traversal, it looks very much like we had in the pre-order, but this time we do this for loop to iterate through the children. Every child in the list of children for the position P, the parameter, I call post-order. That's a recursive call to this method. When I complete all of those, then I perform the visit action for the root itself, the root of the subtree itself that's being called for this algorithm. Let's look at how that works in a specific example. This time, if I asked to traverse, call this method for the root node, which here is paper, I do not first perform the visit action on paper. Instead, I go through each of the children and traverse those. I start with this first child, and it has no children, so I immediately perform the visit action. Then I traverse to the next child, and again, it has no children, so I perform that action. Then I go to the next child of the original node paper, but this time it has children, so I process those children first. Then I process the root node. Please pause the video and continue this. Make sure that you can follow this process, and then I will show you the solution. Here's the solution for that. In the post-order traversal, I start with the root node, but don't do the visit action yet, title to abstract. Then for the next child, I visit its children first, then the root node of this subtree. Finally, a next, I go to the subsequent child of the original root node, process its children, and then itself. Same finally for this last child, second to last child. Here's the last child, and then finally I process the root node itself. Let's try an example of that. Post-order traversal for this tree. Please list the order that the nodes are visited in the post-order traversal of the above tree. When there's a choice, proceed from left to right. So pause the video now and try this, and then I'll give the solution. The solution here is I start at my root node, but I don't process it. I do the children one at a time. I'll go to this child, and I don't process it yet. I do its children first, and then it. I go to the next child, process it, but I don't do it until I visit its children. And this child, node six, I don't do the visit action on it until I do the visit action on its children. So I'll do seven and then eight, then the root node for this subtree, then I'm done with that subtree of the subtree. So I'll visit node three and then one, the original root node. So the final answer is four, five, two, seven, eight, six, three, and then one. We'll take a pause here, and you can do a couple of examples, and then I'll return in a second video to describe in order and breadth first traversal.