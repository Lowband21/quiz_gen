 In this segment, we're learning about iterators, which give us a way to traverse through or iterate over a data structure. So an iterator is actually an object, and it gives us a consistent way to step through the elements of a data structure. But the important thing is that it allows a segment of code external to the data structure to traverse the elements. In other words, it's not inside the file that's implementing the data structure itself. It's in the client code, and it gives the users of the data structure a way to step through one by one the elements, and to do it in a convenient and efficient loop. The code for implementing an iterator is often implemented in the same file as the class that stores the data, and it carries out the traversal by directly accessing the internal workings of the data structure. The reason why it's useful to do this is shown in the following example. Let's say I have a game that stores a list of food objects in a singly linked list. So the main code block would traverse and draw the food as follows. I have an index-based loop here where I'm saying i is in the range of the size of the singly linked list. And for each element, I'm going to call get at that index i and then draw. Now, just for a reminder, food stores is a singly linked list, so for reference, notice what get has to do. Here's the code for get. I start with current equaling the head of the singly linked list, and then I do a loop through the singly linked list until I get to the right index. Each time, I increment the value of current, so I'm stepping through till I get to the correct index. And finally, I return the value of the current node. Now, you might not realize this without looking carefully, but because get is called inside of a for loop, this is actually a nested for loop. And let's count how long this will take by counting the instructions. So for example, i here is varying, and when i takes its first value, which is zero, I jump into foodstores.get at zero. I have one line here, then a for loop for i in range zero. So this line current equals current.next is executed zero times. I'm not paying much attention to the current equals self.head or the return current.value, because in terms of runtime, the key line of code is current equals curtain.next because it happens inside of a for loop. So back up to here now, when i is zero, that current equals current.next was executed zero times. When i is now one and I call get with i equal one, I jump into this method current is self.head, and now I have for i in range one, which will execute this line current equals current.next exactly one time. Execute the last line, then return when i is two, I jump again into get and current is self.head for i in range two, current equals current.next will execute two times. Back up to here, when i is three, I jump into here for i in range three and current equals current.next is executed three times, and so on. So what is the total number of times that this code, this line here, gets executed? The number of times that we execute current equals current.next is zero plus one plus two and so on, up to the last value of i, which is n minus one. Now we've already learned how to add this type of expression, but let's review it. The idea is to add these values up in pairs. The first pair adds to n minus one. The second pair adds to n minus one again. Two plus n minus three is again n minus one, and so on. So I have n minus one is the sum for each of the pairs, and I have a total of n divided by two pairs. So that means that my total number of times that line is executed is equal to n times n minus one over two. And if I expand that, I get n squared minus n over two. So the algorithm is order n squared. Notice that by using get at index as a way of traversing this list, we accidentally created a big O of n squared algorithm just to traverse the list. And traversing lists should always be done in big O of n times. So we need to fix this inefficiency, and we'll do so by using an iterator. So how do we use the iterators in Python? We can use iterators to traverse data whenever the corresponding class that we're trying to iterate through is iterable. To make a class iterable, you have to give it an under-iter method. The double underscore iter method, its job is to create and return an iterator object, and then the caller can use that object to traverse the list. And I'll show you how to do that shortly. Details on how to create the double underscore iter method will be explained in the next video. Now once you've made a class iterable, meaning it has an iter method, now instead of using a get method to traverse the list, you can instead use a while loop or a content-based for loop to traverse the stored data. Let me show you how this looks. The first way that I show you is going to be done with a Python list, because Python lists automatically are iterable. So the first way to traverse a list is the one that you've already seen. For i in range, length of the list, you access the ith element. This is like a get statement. You store the value, and then you do something with the value. We think of those as index-based loops, and you're used to doing that with a Python list. With an iterator, however, you can do the same thing explicitly by letting iter of a list be stored into this it iterator object. Then I loop, and each time through the loop, I call next on the iterator, and I store what it returns. Now in this loop, you can do whatever you like with that value that you're traversing through and receiving each time through the loop. When you reach the end of the list that you're iterating over, the next function will raise a stop iteration exception, and at that point, you can break out of the while loop. This break statement means quit the while loop. It's not actually common at all to use a loop like that because in Python, there's a way to do a for loop that uses an iterator, and that's what we think of as a content-based loop. You're very familiar with this from last quarter. Instead of the while loop shown above, instead you can say for value in a list, do something interesting with value. I'm showing you this so that you realize that a content-based loop behind the scenes is using an iterator. We'd like to be able to do something quite like this for loop, but using a singly linked list, and we can't do that yet because we haven't implemented an iterator in our singly linked list. But once we do, if we have, for example, a singly linked list called my data, we can traverse it now, not just in this first for loop, but there'll be two more techniques. So here's the first way. You already know this way. For i in the range of whatever the size of the singly linked list is, you call get on that singly linked list with this index i, and you store the result, and then you do something. Now, we've already seen that the order of this loop is n squared unnecessarily, so we're going to improve it now using an iterator once we implement iterators in singly linked lists, and we can do that with a while loop just like you saw before. You call the iter function on your singly linked list, store it as the iterator object, then in a while loop in a try block, you call next on your iterator object and store the value, and then you do whatever it is you want to do with that value. You've got an exception possibility here, and if you hit the stop iteration, meaning you're ending your end of the list, you just break out of that while loop. Again, method two is not frequently done at all in Python because Python has content-based loops, so once we create the iterator for a singly linked list, we'll be able to do what should feel very natural to you, which is to just say use the type of loop you're so familiar with from the first two quarters you've studied, which is to say for value in my data where my data is a singly linked list, and then within that content-based for loop, you just do whatever it is you want to do with the element in the singly linked list. So this is what the code looks like in the client, the user of singly linked list, and in the next video, we'll see how to implement all this in our singly linked list class.