 We're going to look at how to figure out what an efficient way to implement STACK is. Remember that the STACK ADT is just an interface, meaning a list of methods for interacting with the underlying data. The person implementing the interface is the one who makes the choice of what underlying data structure to use and how to implement the methods. For example, when implementing STACK, we can make any of the following choices. We could use an array pushing and popping at the first index of the array. Here when I say array, I mean a fixed-sized array, like a NumPy array and not a Python list. We could also use an array pushing and popping, but doing so at the last unused index of the array. Instead, we could choose to use a singly-linked list, pushing and popping at the tail or end of the linked list. We could use a singly-linked list, pushing and popping at the beginning or head of the list. Or we could use a doubly-linked list with sentinel nodes, pushing and popping at either the header or maybe the trailer of the list. Some of these choices are better than others, so now we're going to start examining which ones are better and why. In this segment, I'm going to talk about the first two options, using an array, either pushing and popping at the first index of the array, or pushing and popping at the last unused index of the array. So let's get into the nitty-gritty details. Let's start by looking at how things would go if I implement STACK with an array with the top of the stack stored at the first index of the array. So we start with an empty stack, and when we use arrays, they're allocated with some fixed initial size. So imagine that I've got my empty stack, and my array is sitting there waiting to take elements of the stack as they get pushed. So let's see what happens when we push the values 10, 20, 30, 40, and 50 successively onto the stack using the beginning or first index of the array as the top of the stack. So let's say the first command then is PUSH 10, and when I do that, I just stick a 10 at index 0 of the list, and that took just one assignment statement. Now I'm going to say PUSH 20, and when I PUSH 20 onto the top of the stack, since I'm storing the top of the stack here at the beginning of the array, I'm going to have to move that 10 into the next position, and then put the 20 into the index 0 position. That took two assignment statements. When I PUSH 30, it's supposed to be put into the top of the stack, which is right here at the beginning of my array, but that spot's being used. So in order to clear it, I'm going to have to move the elements in the stack downwards, and I'm going to start at the end here. So first I'll copy the 10 over, then I'll copy the 20 over into the spot where the 10 is, and finally I can put 30 into that index 0 spot at the top of the stack. And that took three assignments. PUSH 40, you get the pattern here. One, two, three, four assignments to PUSH the 40 onto the top of the stack. PUSH 50, oh boy, one, two, three, four, five assignments. Now I'll pop. In order to pop, I take the 50 at the top, save it so that I can return it, and then look, I now have to shift the elements back towards the top of the stack. And that whole process took several steps. Let's make some conclusions about this. If we use an array and store the top of the stack in index 0, then we're stuck shifting the contents of the existing stack to PUSH to make room for the new element. And we're also forced to shift the contents of the existing stack to POP to close up the gap that comes from deleting an element. This process is O of N, where N is the size of the existing stack. That is the order of growth for one PUSH. It turns out that the order of growth can be reduced simply by realizing that we can store the top of the stack at the end of the array, meaning the last unused index, instead of at the beginning. So let's go through the details of that. So again, we start with an empty stack with a fixed allocated size. And we're going to look again at what happens when we PUSH 10, 20, 34, and 50 onto the stack. This time, I PUSH 10. That's one assignment. But when I PUSH 20, I'm not going to slide the 10 over to make room for the 20. Instead, I'm just going to put the 20 right here and consider that the top of the stack. The right end is going to be the top of the stack. And in this situation, it takes just one assignment. Similarly, PUSH 30 takes one assignment, 40, one assignment, and 50, one assignment. This time when I want to POP, I don't have to do any shifting. I simply return the value at the last used index of the array. Let's see what the conclusions are. If we use an array and store the top of the stack at the last available index, then no shifting is necessary for either PUSH or POP. Pushing or POPing a single element is O of 1, or constant time. The order of growth and thus the speed at which the code runs and the ease of implementation is reduced just by storing the top of the stack at the end of the array instead of at the beginning. This example shows us how important it is to thoughtfully choose what data structures we use and to design how we use them. We're going to be implementing stack as a singly linked list, or maybe a doubly linked list. And you're going to need to think about how things work out in this situation. So here are some questions that you should be answering for yourself before designing your own implementation. If you used a singly linked list to store the elements of a stack, if we store it so that the top of the stack is at the end, or should we use the beginning? So what's the growth or the order of growth for the algorithm for PUSHing if you use the end of the stack as the place to put the top of the stack? Excuse me, if you use the end of the singly linked list to store the top of the stack, what's going to be the order of growth for PUSHing and POPing? And then what if you use a singly linked list to store elements in the stack, but store it so that the top of the stack is at the beginning of the singly linked list? Then what order of growth is the algorithm for PUSHing and for POPing? And then finally, if instead you use a doubly linked list, is it more efficient to store the items so that the top of the stack is at the head header or beginning? Or should we use the trailer or the end of the doubly linked list? This kind of question always has to be answered when we design implementations of an ADT.